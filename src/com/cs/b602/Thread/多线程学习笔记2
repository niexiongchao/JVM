第二章
synchronize锁的是对象，谁先访问类的同步方法，则先获取对象锁
多个对象会产生多个对象锁
多个线程访问同一个对象，会产生非线程安全，只有共享的资源才需要同步，非共享资源补用考虑同步
当一个类中存在同步方法和非同步方法时，非同步方法可以被异步访问，同步方法需要同步访问
当一个类中存在两个不同的同步方法时，线程A调用其中一个同步方法，B线程需要等待A调用同步方法完成以后，才能调用同一对象其他同步方法

脏读：读取数据不一致，读取变量时，被其他线程更改，出现在非同步方法
synchronize锁的重入，即该线程已经获得了锁，可以再次获得该对象锁。自己可以再次获得自己内部的锁
当存在父子类继承时，子类可以通过“可重入锁调用父类的同步方法”
当代码抛出异常，线程结束，自动释放锁
父类与子类，同步不能继承，子类重写父类的方法时，也要加上synchronize锁


syn同步方法的弊端：导致其他线程等待时间很长
解决方法，使用syn代码块，syn(this)代码块内的代码同步执行，非syn(this)同步代码块可以被其他线程访问，syn代码块相较于syn方法，可以更加细化

syn代码自身的同步性
同syn方法，当syn(this)代码块被访问时，其他syn(this)代码块不可被访问，其他线程会被阻塞
syn代码块同syn方法一样，锁定当前对象

synchronize 可用于静态方法上，效果是对当前的*.class文件持锁，class锁对所有该类的实例对象起作用，即所有该类的对象同步
持有的锁相同则同步执行，不同锁异步执行

string类型存储再常量池中，当两个string 变量值相同时，代表同一对象，则syn(string)时，会获取相同对象的锁，导致同步

syn方法无限等待问题及解决，使用syn(object)代码块解决，设置object不同，如syn(object1){code1},syn(object2){code2},则两段代码可以异步执行


多线程的死锁：等待一个不可能释放的资源

并发：多个线程交替使用一个资源
并行：多个线程同时进行，使用不同资源

volatile
多继承大的情况下，使用Runnable接口实现多线程

volatile是强制从公共堆栈中取得变量值，每个线程都有自己的私有成员，但是使用volatile修饰后，线程会从公共堆栈中取值,并且值改变后，立即写入公共区域，保证数据同步

volatile缺点：不支持原子性

volatile和syn的比较
volatile是线程同步轻量级的实现，性能优于syn,，volatile只修饰变量，syn修饰方法和代码块
多线程访问volatile不会发生阻塞，syn会发生
volatile能保证数据的可见性，但不能保证原子性；syn可以保证原子性，间接保证可见性,因为它会将私有内存和公共内存数据做同步
volatile是解决变量再多线程的可见性，syn是解决多线程之间访问资源的同步性

线程安全包含原子性和可见性两方面

非原子操作：i++,非线程安全，需要进行同步
使用原子类进行操作atomic,例如private AtomicInteger count = new AtomicInteger(0)




 

